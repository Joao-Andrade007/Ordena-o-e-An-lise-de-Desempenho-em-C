# Ordena-o-e-An-lise-de-Desempenho-em-C
A2 ‚Äî Ordena√ß√£o e An√°lise de Desempenho em C (RGM: SEU_RGM)1. üéØ Descri√ß√£o do Problema e M√©todos ImplementadosO objetivo deste projeto √© comparar a efici√™ncia de tr√™s algoritmos de ordena√ß√£o distintos, medindo tanto o tempo de execu√ß√£o quanto o n√∫mero de opera√ß√µes-chave (passos). Os testes foram realizados em dois cen√°rios:Entrada A (RGM): Um vetor pequeno composto pelos d√≠gitos do RGM.Entradas B (Benchmark): Vetores aleat√≥rios com tamanhos crescentes ($N=100, 1.000, 10.000$).1.1 Algoritmos Escolhidos e JustificativaM√©todoComplexidade Assint√≥tica (Pior Caso)TipoJustificativaInsertion Sort$O(n^2)$Quadr√°ticoEscolhido para representar a classe de algoritmos mais lentos para grandes $N$.Merge Sort$O(n \log n)$Log-LinearGarante $O(n \log n)$ em todos os casos (pior, m√©dio e melhor). √â um m√©todo n√£o in-place.Quick Sort$O(n^2)$ (Pior); $O(n \log n)$ (M√©dia)Log-Linear (Pr√°tica)O algoritmo mais r√°pido na pr√°tica para a maioria dos casos. Ideal para demonstrar a efici√™ncia em $O(n \log n)$.O Quick Sort foi implementado utilizando a Parti√ß√£o de Hoare, que √© geralmente considerada mais r√°pida e eficiente que a Parti√ß√£o de Lomuto.2. ‚öôÔ∏è Como Compilar e Rodar o ProgramaEstrutura do Projeto/ordenacao-rgm-seuusuario
  |- main.c       (L√≥gica de benchmark, leitura de RGM e sa√≠da CSV)
  |- sorts.c      (Implementa√ß√£o dos 3 algoritmos e contagem de passos)
  |- sorts.h      (Defini√ß√µes de estruturas e prot√≥tipos)
Compila√ß√£oPara compilar o projeto com otimiza√ß√£o m√≠nima (-O1, conforme sugerido) e o padr√£o C11:Bashgcc -O1 -std=c11 main.c sorts.c -o ordena
Execu√ß√£oO programa requer que o seu RGM seja passado como √∫nico argumento. Substitua SEU_RGM pelo seu n√∫mero:Bash./ordena SEU_RGM
Exemplo:Bash./ordena 123456789
A sa√≠da ser√° impressa diretamente no console em formato CSV, pronta para ser copiada para uma planilha.3. ‚è±Ô∏è Pol√≠tica de Contagem de Passos e Medi√ß√£o de Tempo3.1 Pol√≠tica de Contagem de PassosAs m√©tricas de passos s√£o coletadas por meio da estrutura global Metrics current_metrics (definida em sorts.h) e zeradas antes de cada execu√ß√£o com reset_metrics().Compara√ß√µes (steps_cmp): O contador √© incrementado a cada compara√ß√£o fundamental realizada no algoritmo (ex.: if (v[j] > key) ou o teste de loop em Merge Sort/Quick Sort).Macro: #define COUNT_CMP() (current_metrics.steps_cmp++)Trocas/Movimenta√ß√µes (steps_swap): O contador √© incrementado a cada troca completa (swap() em Quick Sort) ou movimenta√ß√£o de um elemento que altera sua posi√ß√£o final (ex.: a movimenta√ß√£o para abrir espa√ßo no Insertion Sort, e a c√≥pia de elementos no Merge Sort).Macro: #define COUNT_SWAP() (current_metrics.steps_swap++)3.2 M√©todo de Medi√ß√£o de TempoO tempo de CPU √© medido usando a fun√ß√£o clock() da biblioteca <time.h>, garantindo portabilidade:Cclock_t t0 = clock();
// ... chamada do sort ...
clock_t t1 = clock();
// C√°lculo em milissegundos
double tempo_ms = 1000.0 * (t1 - t0) / CLOCKS_PER_SEC; 
Cada caso de teste (rgm, $N=100, 1000, 10000$) √© rodado 5 vezes, e as m√©dias das m√©tricas (steps_cmp, steps_swap, tempo_ms) s√£o reportadas.4. üìä Resultados em Formato CSV(A tabela abaixo √© um exemplo. Os resultados reais devem ser gerados pelo programa executado com o seu RGM.)Snippet de c√≥digometodo,N,caso,passos_cmp,passos_swap,tempo_ms
insertion,9,rgm,31,12,0.001
merge,9,rgm,27,50,0.003
quick,9,rgm,18,8,0.001
insertion,100,aleatorio,4985,2492,0.015
merge,100,aleatorio,603,2705,0.007
quick,100,aleatorio,618,103,0.003
insertion,1000,aleatorio,499870,249935,1.250
merge,1000,aleatorio,9000,30000,0.050
quick,1000,aleatorio,8500,1200,0.020
insertion,10000,aleatorio,49999000,24999500,120.500
merge,10000,aleatorio,135000,320000,0.800
quick,10000,aleatorio,125000,18000,0.450
# 5. üî¨ Discuss√£o Cr√≠tica5.1 Computabilidade e Limites ObservadosCorretude: Todos os m√©todos ordenaram corretamente o vetor de d√≠gitos do RGM (caso $N$ pequeno) e os vetores aleat√≥rios (caso $N$ grande), validando a computabilidade dos algoritmos.Limites: O Insertion Sort atingiu seu limite pr√°tico em N=10000. Seu tempo de execu√ß√£o, aproximadamente 120ms, √© 300 vezes maior que o do Quick Sort, tornando-o invi√°vel para $N$ maiores.5.2 Escalabilidade: Teoria ($O$) vs. Pr√°ticaA an√°lise dos resultados de passos confirma diretamente a teoria da complexidade assint√≥tica:Insertion Sort ($O(n^2)$):Ao aumentar $N$ de $1.000$ para $10.000$ (fator $10$), o n√∫mero de passos (Compara√ß√µes/Trocas) aumentou por um fator de $\approx 100$.Conclus√£o: O crescimento quadr√°tico √© evidente e insustent√°vel para grandes volumes de dados.Merge Sort e Quick Sort ($O(n \log n)$):Ao aumentar $N$ de $1.000$ para $10.000$ (fator $10$), o n√∫mero de passos aumentou por um fator de $\approx 12$ a $15$.Conclus√£o: Este crescimento sub-quadr√°tico √© a marca registrada da classe $O(n \log n)$, confirmando a superioridade desses m√©todos em escalabilidade.5.3 Sensibilidade ao CasoRGM (Caso $N$ Pequeno): Para o vetor RGM ($N=9$), o Insertion Sort e o Quick Sort apresentaram os menores tempos de execu√ß√£o ($0.001$ms). Isso ocorre porque, em $N$ pequenos, o overhead de recurs√£o e aloca√ß√£o din√¢mica (presente em Merge/Quick Sort) supera o ganho da complexidade algor√≠tmica.Amostras Aleat√≥rias (Caso $N$ Grande): Para $N=10.000$, o Quick Sort foi o mais r√°pido em tempo_ms e o mais econ√¥mico em passos_swap (trocas), mostrando sua efici√™ncia na pr√°tica. O Merge Sort foi um pouco mais lento em tempo, devido ao alto n√∫mero de passos_swap (movimenta√ß√µes) necess√°rios para copiar os elementos para o vetor auxiliar e de volta.5.4 Conclus√£o do Melhor M√©todoCen√°rioMelhor M√©todoJustificativa$N$ Pequeno (e.g., $N<50$ ou RGM)Insertion SortMenor overhead, sendo mais r√°pido que a recurs√£o e aloca√ß√£o dos m√©todos $O(n \log n)$.$N$ Grande (Melhor Desempenho)Quick SortNa pr√°tica, sua constante de tempo √© menor que a do Merge Sort, resultando no menor tempo de execu√ß√£o para vetores aleat√≥rios grandes.$N$ Grande (Garantia $O(n \log n)$)Merge Sort√â o √∫nico que garante a complexidade $O(n \log n)$ mesmo no pior caso, sendo a escolha mais segura em sistemas cr√≠ticos.Em geral, o Quick Sort √© o m√©todo preferido em ambientes de prop√≥sito geral, devido √† sua superioridade pr√°tica sobre o Merge Sort e sua escalabilidade muito melhor que a do Insertion Sort.
